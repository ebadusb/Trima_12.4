/*******************************************************************************
 *
 * Copyright (c) 1998 by Cobe BCT, Inc.  All rights reserved.
 *
 * Revision 1.21  2006/11/27 17:06:29Z  jheiusb
 * 7344 -- add independent stroke volume alg for MSS so adding MSS as a valid state in the transition table
 * Revision 1.20  2003/09/09 22:44:50Z  ms10234
 * 6406 - fix pfr code
 * Revision 1.19  2003/07/21 21:13:12Z  td07711
 * IT6157 - no need to shutdown in ResetCycleVol()
 * Revision 1.18  2003/07/01 22:33:53Z  ms10234
 * 5818 - changed log levels from debug to info type.
 * Revision 1.17  2003/04/03 22:20:28Z  pn02526
 * Update logging per J. Linder memo in EDHF/design_input/log_categories.doc
 * Revision 1.16  2003/04/01 16:57:47  pn02526
 * Changes per IT 5950
 * Revision 1.15  2002/08/07 17:25:51Z  pn02526
 * Remove "trace" external; use DataLog_Default instead.
 * Revision 1.14  2002/07/23 16:52:23  pn02526
 * Remove "DataLog_Level log" and use external "trace" instead.
 * Revision 1.13  2002/04/15 09:55:51  pn02526
 * Change log(LOG_ALARM_DETAIL) to alarm_detail(LOG_ALARM_DETAIL)
 * Revision 1.12  2002/04/08 11:06:11  pn02526
 * Revise logging to use DataLogLevel class.  Revise FATAL_ERROR calls to use the new one.  Change ASSERT() macro calls to trima_assert().
 * Revision 1.11  2002/03/05 01:02:18Z  ms10234
 * 5613 -  Initialized containers to enable monitoring when the set type is unknown.  Enabled monitoring for AC pump always when the donor is connected.
 * Revision 1.10  2002/03/01 22:37:21  ms10234
 * 5613 - Increased the robustness of the AC pump monitor by enabling
 * the monitor whenever the donor is connected, regardless of state.
 * The exceptions are for rinseback and donor disconnect states where
 * rinseback monitoring is in effect.
 * Revision 1.9  2001/08/27 21:37:21  ms10234
 * 5271 -  Remove references to stamp color
 * Revision 1.8  2000/11/01 18:55:53  bs04481
 * Back to match rev 1.6.  Evaluate AC ratio too High when the AC
 * pump is commanded to non-zero.
 * Revision 1.7  2000/10/31 14:40:22  bs04481
 * In IsACOffDuringDraw, check for a commanded speed of greater
 * than 0 instead of non-zero.
 * Revision 1.6  2000/07/06 01:18:44  bs04481
 * Variable name change
 * Revision 1.5  2000/03/15 18:01:35  BS04481
 * Use acCommand element instead of pointer to control orders
 * Revision 1.4  1999/09/24 22:58:16  BS04481
 * Fix problem found by Microsoft compiler.
 * Revision 1.3  1999/08/01 20:52:58  BS04481
 * Non-critical code review changes identified at the 3.2 release.
 * Revision 1.2  1998/11/05 19:30:02  bs04481
 * Correct ASSERT usage.  Add assert if Control Order structure
 * is NULL.  Code review changes.
 * Revision 1.1  1998/05/12 19:49:35  bs04481
 * Initial revision
 *
 *
 * TITLE:      acratiop.cpp, the object which monitors AC ratio
 *             in the context of unexpected pump speeds
 *
 * ABSTRACT:   Safety's monitoring for AC ratio alarms which are
 *             generated by mismatched or unexpected pump speeds.
 *
 */


#include <stdio.h>
#include <stdlib.h>

#include "trima_datalog.h"
#include "trima_assert.h"
#include "alarms.h"

#include "chw.hpp"

#include "acratio.hpp"
#include "s_pfr.hpp"
#include "s_donor.hpp"

// global definition for Safety PFR data
extern SPFRecovery SafetyPFRDataToSave;
extern SPFRecovery SafetyPFRDataFromRestore;


/*******************************************************************************
 *
 *  ACRatioPumpVolume Methods
 *
 ******************************************************************************/

// SPECIFICATION:    Safety AC Ratio pump monitoring constructor
//
// ERROR HANDLING:   none.

ACRatioPumpVolume::ACRatioPumpVolume(InletContainer* InletCont,
                                     ReturnContainer* ReturnCont,
                                     ACContainer* ACCont,
                                     aDonor* paDonor)
   : _Inlet(InletCont), _Return(ReturnCont), _AC(ACCont), _paDonor(paDonor)
{
   _fAccumACTooFastVolume     = 0.0f;
   _iHighRatioPersistsCounter = 0;
   _bACRatioMonitoringActive  = TRUE;
   _dumpFlag                  = TRUE;

   // fatal if containers are not initialized
   trima_assert(_Inlet);
   trima_assert(_Return);
   trima_assert(_AC);
   trima_assert(_paDonor);

   SaveToPFR();
}

// SPECIFICATION:    Safety AC Ratio pump monitoring destructor
//
// ERROR HANDLING:   none.
ACRatioPumpVolume::~ACRatioPumpVolume()
{
   _Inlet  = NULL;
   _Return = NULL;
   _AC     = NULL;
}

// SPECIFICATION:    Initialize AC Ratio pump monitoring for appropriate state
//
// ERROR HANDLING:   none

void ACRatioPumpVolume::InitializeForState (long newState)
{
   switch (newState)
   {
      case BLOOD_RINSEBACK :
      case DONOR_DISCONNECT :
      case METERED_STORAGE :
         _bACRatioMonitoringActive = FALSE;
         break;
      default :
         if ( _paDonor->GetDonorConnectedState() == DONOR_IS_CONNECTED )
            _bACRatioMonitoringActive = TRUE;
         else
            _bACRatioMonitoringActive = FALSE;
         break;

   }
   SaveToPFR();
}

// SPECIFICATION:    Test for AC running faster than (inlet - return)
//                   during a draw cycle.
//
//
// ERROR HANDLING:   INAPPROPRIATE_AC_PUMP_MOVEMENT alarm

void ACRatioPumpVolume::IsACTooFast ()
{
   float deltaAC, deltaInlet, deltaReturn;

   // Get the volumes added in this sample period
   deltaAC     = _AC->GetVolume(VOL_DELTA);
   deltaInlet  = _Inlet->GetVolume(VOL_DELTA);
   deltaReturn = _Return->GetVolume(VOL_DELTA);

   // if AC pump is running faster than (inlet - return), it is causing
   // a flow to the donor at the manifold.  That would not be good.
   if ( (deltaAC > .0005f)
        &&(deltaAC > (deltaInlet - deltaReturn) ) )
   {
      // If we haven't exceeded the allowance, we still need to accumulate it
      // and test.  The accumulator is reset at the switch to draw
      _fAccumACTooFastVolume += deltaAC;
      if ( _fAccumACTooFastVolume >= 0.40f )
      {
         paSafetyHardwareCommandsExec->respond_to_alarm(OFF_BOTH, INAPPROPRIATE_AC_PUMP_MOVEMENT);
         if (_dumpFlag == TRUE)
         {
            _dumpFlag = FALSE;
            Dump(log_level_safety_alarm_detail);
         }
         DataLog(log_level_safety_alarm_detail) << "Accum INAPPROPRIATE_AC_PUMP_MOVEMENT Ratio _fAccumACTooFastVolume = "
                                                << _fAccumACTooFastVolume
                                                << ", deltaAC = "
                                                << deltaAC
                                                << endmsg;
      }
      else
      {
         DataLog(log_level_safe_exec_info) << "Accum AC at low Ratio _fAccumACTooFastVolume = "
                                           << _fAccumACTooFastVolume
                                           << ", deltaAC = "
                                           << deltaAC
                                           << endmsg;
      }
   }

   return;
}


// SPECIFICATION:    Test for AC not running during a draw cycle
//
//
// ERROR HANDLING:   AC Ratio Too High alarm

void ACRatioPumpVolume::IsACOffDuringDraw (char cCycle, float acCommandRPM)
{
   float deltaAC;
   float deltaInlet;
   float deltaReturn;

   // if this is not a draw cycle or the orders are NULL, just return
   if (cCycle != DRAW_CYCLE )
      return;

   // Get the volume added in this sample period
   deltaAC     = _AC->GetVolume(VOL_DELTA);
   deltaInlet  = _Inlet->GetVolume(VOL_DELTA);
   deltaReturn = _Return->GetVolume(VOL_DELTA);

   // if the AC pump is ordered on and the pump power is not
   // blocked due to too long of a pause, check that the
   // AC pump is really running (while the inlet or return pump
   // are drawing blood from the donor).  If it is not, increment a
   // counter and check that the counter has not exceeded the
   // allowed tolerance for running without AC entering the system.
   // The counter is reset at the switch to draw cycle.

   if (    ( deltaAC <= .0005f )
           && ( acCommandRPM != 0.0f )
           && ( paSafetyHardwareCommandsExec->isPowerBlocked() == FALSE )
           && ( deltaInlet > .0005f || deltaReturn <-.0005f )
           )
   {
      _iHighRatioPersistsCounter++;
      if (_iHighRatioPersistsCounter > HIGH_RATIO_FILTER )
      {
         paSafetyHardwareCommandsExec->respond_to_alarm(OFF_BOTH, AC_RATIO_TOO_HIGH_ALARM);
         if (_dumpFlag == TRUE)
         {
            _dumpFlag = FALSE;
            Dump(log_level_safety_alarm_detail);
         }
         DataLog(log_level_safety_alarm_detail) << "AC_RATIO_TOO_HIGH_ALARM Ratio: N/C, High Count: "
                                                << (int)_iHighRatioPersistsCounter
                                                << " deltaAC: "
                                                << deltaAC
                                                << endmsg;
      }
      else
      {
         // log ratio too high occurance
         DataLog(log_level_safe_exec_info) << "deltaAC < 0.0005 Ratio: N/C, High Count: "
                                           << (int)_iHighRatioPersistsCounter
                                           << " deltaAC: "
                                           << deltaAC
                                           << endmsg;
      }
   }

   return;

}


// SPECIFICATION:    Test for AC running during a return cycle
//
//
// ERROR HANDLING:   AC On During Return alarm

// Deleted per IT 5950 04/01/2003 PCN, and this is No April fools.


// SPECIFICATION:    Test for AC ratio conditions which are
//                   associated with pumps mismatched or running
//                   at unexpected times.
//
//
// ERROR HANDLING:   none

void ACRatioPumpVolume::Update (char cCycle, float acCommandRPM)
{
   // if AC ratio monitoring is active, do the tests
   if (_bACRatioMonitoringActive == TRUE)
   {
      // test the conditions
      IsACTooFast();
      IsACOffDuringDraw(cCycle, acCommandRPM);
   }

   // save data to PFR
   SaveToPFR();
   return;
}

// SPECIFICATION:    AC Ratio pump volume monitoring method to reset
//                   volumes at the start of the draw cycle
//
// ERROR HANDLING:   none.

void ACRatioPumpVolume::ResetCycleVol (char cCycle)
{
   if (cCycle == DRAW_CYCLE)
   {
      _fAccumACTooFastVolume     = 0.0f;
      _iHighRatioPersistsCounter = 0;
   }
   SaveToPFR();
}

// SPECIFICATION:    Dump container data
//
// ERROR HANDLING:   none.

void ACRatioPumpVolume::Dump (DataLog_Level log_level)
{
   _Inlet->DumpContainer(log_level);
   _Return->DumpContainer(log_level);
   _AC->DumpContainer(log_level);
}

// SPECIFICATION:    Save data to PFR
//
// ERROR HANDLING:   none.

void ACRatioPumpVolume::SaveToPFR ()
{

   SafetyPFRDataToSave.PFR_fAccumACTooFastVolume             = _fAccumACTooFastVolume;
   SafetyPFRDataToSave.PFR_iHighRatioPersistsCounter         = _iHighRatioPersistsCounter;
   SafetyPFRDataToSave.PFR_acRatioP_bACRatioMonitoringActive = _bACRatioMonitoringActive;

}

// SPECIFICATION:    Restore data from PFR
//
// ERROR HANDLING:   none.

void ACRatioPumpVolume::RestoreFromPFR ()
{

   _fAccumACTooFastVolume     = SafetyPFRDataFromRestore.PFR_fAccumACTooFastVolume;
   _iHighRatioPersistsCounter = SafetyPFRDataFromRestore.PFR_iHighRatioPersistsCounter;
   _bACRatioMonitoringActive  = SafetyPFRDataFromRestore.PFR_acRatioP_bACRatioMonitoringActive;

   DataLog(log_level_safe_exec_info) << "ACRatioPumpVolume::RestoreFromPFR(), "
                                     << "fAccumACTooFastVolume: " << _fAccumACTooFastVolume
                                     << " iHighRatioPersistsCounter: " << _iHighRatioPersistsCounter
                                     << " bACRatioMonitoringActive: " << _bACRatioMonitoringActive
                                     << endmsg;

   SaveToPFR();
}

/* FORMAT HASH 7bf571614d30704bc1405bd7fa870f1b */
